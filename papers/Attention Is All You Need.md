# 0 摘要
主要的序列转导模型基于复杂的循环或卷积神经网络，其中包括一个编码器和一个解码器。表现最好的模型还通过注意机制连接编码器和解码器。我们提出了一种新的简单网络结构，Transformer，完全基于注意机制，避免了重复和卷积。在两个机器翻译任务上的实验表明，这些模型具有更高的质量，同时具有更强的并行性和更少的训练时间。我们的模型在WMT 2014英德翻译任务中达到28.4 BLEU，比现有的最佳结果(包括集成)提高了2倍以上。在WMT 2014英法翻译任务中，我们的模型在8个gpu上训练3.5天后，建立了一个新的单模型最先进的BLEU分数为41.8，这只是文献中最好模型训练成本的一小部分。我们表明，通过成功地将其应用于具有大量和有限训练数据的英语选区解析，该转换器可以很好地推广到其他任务。
# 1 介绍
循环神经网络，特别是长短期记忆和门控循环神经网络，已经被牢固地建立为最先进的方法在序列建模和转换问题，如语言建模和机器翻译。自那以后，许多努力不断地推动循环语言模型和编码器-解码器体系结构的边界。

循环模型通常沿输入和输出序列的符号位置考虑计算。将位置与计算时间中的步骤对齐，它们会根据先前的隐藏状态$h_{t-1}$和位置$t$的输入生成一系列隐藏状态$h_t$。这种固有的顺序性质阻止了训练示例内的并行化，这在较长的序列长度上变得至关重要，因为内存限制限制了示例之间的批处理。最近的工作通过分解技巧和条件计算在计算效率上取得了显着提高，同时在后者的情况下还提高了模型性能。但是，顺序计算的基本约束仍然存在。

注意机制已经成为各种任务中强制序列建模和转导模型的重要组成部分，允许不考虑其在输入或输出序列中的距离的相关性建模。然而，在之外的所有案例中，这种注意机制都与循环网络结合使用。

在这项工作中，我们提出了Transformer，一个避免循环的模型体系结构，而完全依赖于一个注意机制来绘制输入和输出之间的全局依赖关系。Transformer允许更多的并行化，并且在8个P100 GPU上经过12个小时的训练后，翻译质量达到了一个新的水平。

# 2 背景
减少顺序计算的目标也构成了扩展神经GPU、ByteNet和convs2的基础，它们都使用卷积神经网络作为基本构建块，并行计算所有输入和输出位置的隐藏表示。在这些模型中，从两个任意输入或输出位置关联信号所需的操作数随着位置之间的距离增加而增加，convs2为线性，ByteNet为对数。这使得学习远距离位置之间的依赖关系变得更加困难。在 Transformer 中，这种情况被减少为一个恒定的操作数，尽管代价是由于平均注意力加权位置而降低了有效分辨率，正如第3.2节所述，我们用多头注意力抵消了这种影响。

自我注意，有时也称为内注意，是一种将单个序列的不同位置联系起来的注意机制，目的是为了计算序列的表示法。自我注意已成功地应用于阅读理解、抽象总结、文本蕴涵和学习任务无关的句子表征等多种任务中。

端到端记忆网络是基于一种经常性的注意机制，而不是序列排列的经常性，并已被证明在简单语言的问题回答和语言建模任务中表现良好。

然而，据我们所知，Transformer是第一个完全依靠自我关注来计算输入和输出表示的转导模型，而不使用序列对齐的RNN或卷积。

# 3 模型架构
大多数具有竞争力的神经序列转换模型都具有编码器-解码器结构。这里，编码器映射一个符号表示的输入序列$(x_1,...,x_n)$到连续表示的序列$z = (z_1,...,z_n)$。给定$z$，解码器然后生成一个输出序列$(y_1,...,y_m)$一次一个元素的符号。在每个步骤中，模型都是自回归的，在生成下一个步骤时，使用之前生成的符号作为额外的输入。Transformer遵循这种总体架构，使用了编码器和解码器的堆叠自注意层和点向全连接层，分别如图1的左、右两部分所示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210221131130689.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg1NzY4OA==,size_16,color_FFFFFF,t_70#pic_center)
> 图1:Transformer 模型架构

## 3.1 编码器和解码器堆栈
- 
- **编码器**：编码器由N = 6个相同的层组成。每一层有两个子层。第一层是多头自我注意机制，第二种是一个简单的、位置上全连接的前馈网络。我们在两个子层周围使用一个残余连接，然后进行层规范化。也就是说，每个子层的输出都是$LayerNorm(x + Sublayer(x))$，其中$Sublayer(x)$是子层自身实现的函数。为了方便这些残余连接，模型中的所有子层以及嵌入层都产生了维度$d_{model}= 512$的输出。
- **解码器**：解码器也是由N = 6个相同的层组成的堆栈。除了在每个编码器层的两个子层之外，解码器插入第三个子层，它对编码器堆栈的输出执行多头注意。与编码器类似，我们在每个子层周围使用残余连接，然后进行层标准化。我们还修改了译码器堆栈中的自我注意子层，以防止位置注意到后续位置。这种屏蔽，结合输出嵌入偏移一个位置的事实，确保位置$i$的预测只能依赖于小于$i$位置的已知输出。

## 3.2 注意
注意力函数可以被描述为将一个查询和一组键值对映射到一个输出，其中查询、键、值和输出都是向量。输出计算为值的加权和，其中分配给每个值的权重由查询的兼容函数和相应的键计算。
![在这里插入图片描述](https://img-blog.csdnimg.cn/2021022113162623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg1NzY4OA==,size_16,color_FFFFFF,t_70#pic_center)
> 图2:(左)缩放点积注意力。(右)多头注意力由多个注意层并行运行组成。
### 3.2.1 缩放点积注意力
我们把我们的特别注意称为“缩放点积注意”(图2)。输入包括维$d_k$的查询和键，以及维$d_v$的值。我们用所有键计算查询的点积，每个键除以$\sqrt{d_k}$，然后应用softmax函数来获得值的权重。

在实践中，我们同时计算一组查询的注意函数，并打包成一个矩阵Q。键和值也打包成矩阵K和V。我们计算输出矩阵为:
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210221131911387.png#pic_center)
两种最常用的注意函数是加性注意和点积(乘法)注意。注意点积和我们的算法是一样的，除了比例因子是$\frac{1}{\sqrt{d_k}}$。加法注意使用一个带有单一隐含层的前馈网络来计算兼容性函数。虽然这两种方法在理论复杂度上相似，但点积方法在实践中速度更快，空间效率更高，因为它可以使用高度优化的矩阵乘法代码实现。

当$d_k$值较小时，两种机制的注意表现相似，但当$d_k$值较大时，加性注意优于无缩放的点积注意。我们猜想，当$d_k$的值较大时，点积的值增大，将softmax函数推入了梯度极小的区域。为了抵消这种影响，我们将点积乘以$\frac{1}{\sqrt{d_k}}$。

### 3.2.2 多头注意力
我们发现，用不同的、学习过的线性投影分别对$d_k$、$d_k$和$d_v$维进行$h$次线性投影查询、键和值是有益的，而不是用$d_{model}$维键、值和查询执行单一的注意力功能。在每个查询、键和值的投影版本上，我们并行执行注意力功能，产生$d_v$维输出值。这些连接在一起，再次投影，产生最终的值，如图2所示。

多头注意力允许模型共同关注来自不同位置的不同表征子空间的信息。用一个单一的注意力头，平均抑制这一点。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210221132550865.png#pic_center)
其中，投影是参数矩阵$W^Q_i \in R^{d_{model}\times d_k}$，$W^K_i \in R^{d_{model} \times d_k}$，$W^V_i\in R^{d_{model }\times d_v}$和$W^O \in R^{hd_v \times d_{model}}$。

在这项工作中，我们采用$h = 8$个平行注意层或头部。对于这些中的每一个，我们使用$d_k = d_v = d_{model} / h =64$。由于每个头部的尺寸减小，因此总计算成本类似于具有全尺寸的单头注意力的计算成本。


### 3.2.3 注意力在我们模型中的应用
Transformer通过三种不同方式使用多头注意力：
- 在“编码器-解码器注意”层中，查询来自先前的解码器层，而存储键和值来自编码器的输出。这允许解码器中的每个位置都参与输入序列中的所有位置。
- 编码器包含自我注意层。在自我关注层中，所有键，值和查询都来自同一位置，在这种情况下，是编码器中上一层的输出。编码器中的每个位置都可以覆盖编码器上一层中的所有位置。
- 类似地，解码器中的自我注意层允许解码器中的每个位置关注直到并包括该位置的解码器中的所有位置。我们需要防止解码器中向左流动信息，以保留自回归属性。我们通过掩盖（设置为$-\infty$）softmax输入中与非法连接相对应的所有值，从而在按比例扩大点积注意的范围内实现此目标。参见图2。

## 3.3 位置前馈网络
除了关注子层之外，我们的编码器和解码器中的每个层还包含一个完全连接的前馈网络，该网络分别并相同地应用于每个位置。这由两个线性变换组成，两个线性变换之间具有ReLU激活。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210221133318649.png#pic_center)
虽然线性变换在不同位置上相同，但是它们使用不同的参数。描述它的另一种方法是将两个卷积的核大小设为1。输入和输出的维数为$d_{model} = 512$，内层的维数为$d_{f f} = 2048$。

## 3.4 嵌入和softmax
与其他序列转导模型类似，我们使用学习的嵌入将输入标记和输出标记转换为$d_{model}$维的向量。我们还使用通常学习的线性变换和softmax函数将解码器输出转换为预测的下一个令牌概率。在我们的模型中，我们在两个嵌入层和pre-softmax线性变换之间共享相同的权重矩阵。在嵌入层中，我们将这些权重乘以$\sqrt{d_{model}}$。

## 3.5 位置编码
由于我们的模型不包含循环和卷积，因此为了使模型能够使用序列的顺序，我们必须注入一些有关令牌在序列中的相对或绝对位置的信息。为此，我们在编码器和解码器堆栈底部的输入嵌入中添加“位置编码”。位置编码的维数$d_{model}$与嵌入的维数相同，因此可以将两者相加。位置编码有很多选择，可以学习和固定。

在这项工作中，我们使用不同频率的正弦和余弦函数：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210221133806461.png#pic_center)
其中$pos$是位置，$i$是尺寸。即，位置编码的每个维度对应于正弦曲线。波长形成从$2\pi$到$10000·2\pi$的几何级数。我们选择此函数是因为我们假设它可以使模型轻松学习相对位置的参与，因为对于任何固定的偏移量$k$，$P E_{pos + k}$可以表示为$P E_{pos}$的线性函数。

我们还尝试使用学习的位置嵌入进行实验，发现这两个版本产生的结果几乎相同（请参见表3（E）行）。我们选择正弦曲线版本是因为它可以使模型外推到比训练过程中遇到的序列长度更长的序列长度。



# 4 为什么要自我注意
在本节中，我们将自我注意层的各个方面与通常用于将一个可变长度的符号表示序列$（x_1,...,x_n）$映射到另一个等长序列$（z_1,...,z_n）$的循环层和卷积层进行比较$x_i,z_i\in R^d$。例如典型序列转导编码器或解码器中的隐藏层。为了激发我们的自我注意力，我们考虑了三个愿望。

一种是每层的总计算复杂度。另一个是可以并行化的计算量，以所需的最少顺序操作数衡量。

第三个是网络中远程依赖关系之间的路径长度。在许多序列转导任务中，学习远程依赖性是一项关键挑战。影响学习这种依赖性的能力的一个关键因素是前向和后向信号必须在网络中穿越的路径长度。输入和输出序列中位置的任何组合之间的这些路径越短，越容易学习远程依赖性。因此，我们还比较了由不同层类型组成的网络中任意两个输入和输出位置之间的最大路径长度。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210221133701723.png#pic_center)
> 表1：不同层类型的最大路径长度，每层复杂度和最小顺序操作数。 n是序列长度，d是表示维，k是卷积的核大小，r是受限的注意力集中区域的大小。

如表1所示，自我注意层使用恒定数量的顺序执行的操作连接所有位置，而循环层则需要$O（n）$个顺序操作。就计算复杂度而言，当序列长度$n$小于表示维数$d$时，自注意力层比循环层要快，这是机器翻译中最新模型所使用的句子表示的最常见情况，例如词段和字节对表示形式。为了提高涉及非常长序列的任务的计算性能，可以将自我注意限制为仅考虑输入序列中以各个输出位置为中心的大小为$r$的邻域。这会将最大路径长度增加到$O（n / r）$。我们计划在以后的工作中进一步研究这种方法。

单个核宽度为$k < n$的卷积层并不连接所有的输入和输出位置对。这样做在相邻核的情况下需要$O(n/k)$个卷积层的堆栈，或者在扩展卷积的情况下需要$O(log_k(n))$个卷积层，增加网络中任意两个位置之间的最长路径的长度。卷积层通常比循环层昂贵$k$倍。然而，可分离卷积将复杂度大大降低到$O(k·n·d + n·d^2)$。然而，即使$k = n$，可分离卷积的复杂性也等于自我注意层和点向前馈层的组合，这是我们在模型中采用的方法。

作为附带的好处，自我关注可以产生更多可解释的模型。独立的注意力头不仅清楚地学习执行不同的任务，许多似乎表现出与句子的句法和语义结构相关的行为。

# 5 训练
本节描述我们的模型的训练机制。

## 5.1 训练数据和批处理
我们对标准的WMT 2014英语-德语数据集进行了培训，该数据集包含约450万个句子对。句子是使用字节对编码进行编码的，字节对编码具有约37000个令牌的共享源目标词汇。对于英语-法语，我们使用了更大的WMT 2014英语-法语数据集，该数据集由3600万个句子组成，并将标记拆分成32000个词条词汇。句子对按近似的序列长度进行批处理。每个培训批次包含一组句子对，其中包含大约25000个源标记和25000个目标标记。

## 5.2 硬件和时间表
我们在一台配备8个NVIDIA P100 GPU的计算机上训练了模型。对于使用本文所述的超参数的基本模型，每个训练步骤大约需要0.4秒。我们对基本模型进行了总共100,000步或12个小时的训练。对于我们的大型模型（在表3的底部描述），步长为1.0秒。大型模型接受了300,000步（3.5天）的培训。

## 5.3 优化
我们使用Adam优化器，其中$\beta_1= 0.9$，$\beta_2= 0.98$和$\epsilon = 10^{-9}$。根据以下公式，我们在培训过程中改变了学习率：
![在这里插入图片描述](https://img-blog.csdnimg.cn/2021022113511581.png#pic_center)
这对应于线性增加第一个warmup_steps训练步骤的学习速率，此后按步骤编号的平方根的平方根减小学习速率。我们使用warmup_steps = 4000。


## 5.4 正则
在培训期间，我们采用三种类型的正则化：

- **Residual Dropout**：我们将dropout应用到每个子层的输出，然后将其添加到子层的输入并归一化。此外，我们对编码器和解码器堆栈中的嵌入和位置编码的总和应用dropout。对于基本模型，我们使用$P_{drop}= 0.1$的比率。
- **Label Smoothing**：在训练过程中，我们采用了值$\epsilon _{ls}= 0.1$的标签平滑。这对复杂性造成了伤害，因为模型学会了更不确定，但提高了准确性和BLEU分数。

# 6 结果

## 6.1 机器翻译
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210221135408195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg1NzY4OA==,size_16,color_FFFFFF,t_70#pic_center)
> 表2:在英语到德语和英语到法语的newstest2014测试中，Transformer比之前的最先进的车型取得了更好的BLEU分数，而培训成本仅为一小部分。

在WMT 2014英德翻译任务中，big transformer模型(表2中的transformer (big))比之前报道的最好的模型(包括ensemu)高出2.0 BLEU以上，建立了一个新的最先进的BLEU得分28.4。表3的最后一行列出了该模型的配置。培训在8个P100 GPU上花了3.5天。甚至我们的基础模型也超过了所有以前发布的模型和集成，而训练成本只是任何竞争性模型的一小部分。

在WMT 2014英法翻译任务中，我们的大模型达到了41.0的BLEU分数，优于之前发布的所有单个模型，培训成本低于之前最先进模型的1/4。为英语-法语训练的变压器(big)模型使用的dropout rate   $P_{drop}= 0.1$，而不是0.3。

对于基础模型，我们使用一个通过平均最近5个检查点(每10分钟编写一次)获得的模型。对于大型模型，我们平均了最后20个检查点。我们使用波束搜索，波束大小为4，长度惩罚$\alpha = 0.6$。这些超参数是在开发集上进行实验后选择的。我们将推理过程中的最大输出长度设置为输入长度+ 50，但在可能的情况下提前终止。

表2总结了我们的结果，并将我们的翻译质量和培训成本与文献中的其他模型架构进行了比较。我们通过乘以训练时间、使用的GPU数量和每个GPU持。的单精度浮点容量来估计用于训练模型的浮点操作的数量.

## 6.2 模型变体
为了评估 Transformer 不同组件的重要性，我们以不同的方式改变了我们的基础模型，在newstest2013开发集上测量了英语到德语翻译的性能变化。我们使用了前一节中描述的束搜索，但没有使用检查点平均。我们在表3中给出了这些结果。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210221140050679.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg1NzY4OA==,size_16,color_FFFFFF,t_70#pic_center)
> 表3:Transformer 架构的变体。未列出的值与基本模型的值相同。所有指标都在英德翻译开发集，newstest2013。根据我们的字节对编码，列出的困惑是每个字的困惑，不应该与每个字的困惑进行比较。

在表3行(A)中，我们在保持计算量不变的情况下，改变注意头的数量以及注意键和值维数，如3.2.2节所述。虽然单头注意力比最好的设置差0.9 BLEU，但质量也会随着头的过多而下降。

在表3中的行（B）中，我们观察到减小注意键大小$d_k$会损害模型质量。这表明确定兼容性并不容易，并且比点乘积更复杂的兼容性功能可能会有所帮助。我们进一步在（C）和（D）行中观察到，正如预期的那样，较大的模型更好，并且dropout对于避免过度拟合非常有帮助。在（E）行中，我们将正弦位置编码替换为学习的位置嵌入[9]，并观察到与基本模型几乎相同的结果。

## 6.3 英语选区分析
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210221140331428.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDg1NzY4OA==,size_16,color_FFFFFF,t_70#pic_center)
> 表4：“Transformer ”很好地概括了英语选区分析（结果在《华尔街日报》的第23部分）

为了评估Transformer是否可以推广到其他任务，我们对英语选区解析进行了实验。这项任务提出了具体的挑战：产出受到强大的结构约束，并且比投入的时间长得多。此外，RNN序列到序列模型无法在小数据体制中获得最新的结果。

我们在Penn Treebank的《华尔街日报（WSJ）》上训练了一个$d_{model} = 1024$的4层Transformer，约40K训练语句。我们还使用来自约1700万个句子的较大的高可信度和BerkleyParser语料库，在半监督的情况下对其进行了训练。对于仅WSJ设置，我们使用了16K令牌的词汇表；对于半监督设置，我们使用了32K令牌的词汇表。


我们仅进行了少量实验来选择第22节开发集上的辍学率，注意力和残差（第5.4节），学习率和波束大小，所有其他参数在英语到德语基础翻译模型中均保持不变。在推断过程中，我们将最大输出长度增加到输入长度+300。仅对于WSJ和半监督设置，我们使用21的波束大小和$\alpha= 0.3$。

我们在表4中的结果表明，尽管缺少针对特定任务的调整，我们的模型仍然表现出令人惊讶的出色表现，与循环神经网络语法相比，该模型的结果比以前报告的所有模型都要好。

与RNN序列到序列模型相反，即使仅在40K句子的WSJ训练集上进行训练，该Transformer也优于BerkeleyParser 。

# 7 结论
在这项工作中，我们介绍了Transformer，这是完全基于注意力的第一个序列转导模型，用多头自注意力代替了编解码器体系结构中最常用的循环层。

对于翻译任务，与基于循环层或卷积层的体系结构相比，可以大大加快Transformer的训练速度。在WMT 2014英语到德语和WMT 2014英语到法语的翻译任务中，我们都达到了最新水平。在前一项任务中，我们最好的模型甚至胜过所有先前报告的合奏。

我们对基于注意力的模型的未来感到兴奋，并计划将其应用于其他任务。我们计划将“Transformer”扩展到涉及文本以外的涉及输入和输出形式的问题，并研究局部受限的注意机制，以有效处理大型输入和输出，例如图像，音频和视频。使世代相继减少是我们的另一个研究目标。

我们用于训练和评估模型的代码可从[https://github.com/tensorflow/tensor2tensor](https://github.com/tensorflow/tensor2tensor)获得。